import json
import uuid
from typing import List, Optional, Dict, Any
from datetime import datetime

from loguru import logger
from pydantic import BaseModel, Field
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser

import server.ske.llm_setup as llm_setup
from server.ske.database import Neo4jManager
from server.ske.models import EntityNode, RelationshipType

class InsightEntity(BaseModel):
    name: str = Field(description="Name of the entity")
    type: str = Field(description="Type of the entity (e.g., Concept, Person, Tech)")
    description: str = Field(description="Brief description of the entity")
    reasoning: str = Field(description="Why this is a new insight derived from the content")

class InsightExtraction(BaseModel):
    entities: List[InsightEntity]

class MemoryManager:
    """
    Manages dynamic memory precipitation from Agent interactions.
    """
    
    @staticmethod
    async def extract_knowledge(content: str) -> List[InsightEntity]:
        """
        Uses LLM to extract new insights/entities from agent content.
        """
        if not llm_setup.ske_langchain_llm:
            raise RuntimeError("SKE LLM not initialized. Call initialize_ske_llm() first.")

        parser = JsonOutputParser(pydantic_object=InsightExtraction)
        
        prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a Knowledge Graph expert. Analyze the following text and extract KEY new entities or concepts that represent valuable insights. \n"
                       "Focus on specific, named entities or unique concepts. \n"
                       "Output JSON format.\n{format_instructions}"),
            ("user", "{content}")
        ])
        
        chain = prompt | llm_setup.ske_langchain_llm | parser
        
        try:
            result = await chain.ainvoke({
                "content": content,
                "format_instructions": parser.get_format_instructions()
            })
            
            # Handle potential nested structure
            if isinstance(result, dict) and "entities" in result:
                return [InsightEntity(**item) for item in result["entities"]]
            elif isinstance(result, list):
                # Sometimes LLM might return just a list if prompted loosely, 
                # but with format_instructions it usually adheres to schema.
                # If it's a list of dicts matching InsightEntity
                try:
                    return [InsightEntity(**item) for item in result]
                except:
                    logger.warning(f"List returned but items might not match schema: {result}")
                    return []
            else:
                logger.warning(f"Unexpected LLM output format: {result}")
                return []
        except Exception as e:
            logger.error(f"Failed to extract insights: {e}")
            return []

    @staticmethod
    async def get_embedding(text: str) -> List[float]:
        if not llm_setup.ske_langchain_embeddings:
             raise RuntimeError("SKE Embeddings not initialized. Call initialize_ske_llm() first.")
        return await llm_setup.ske_langchain_embeddings.aembed_query(text)

    @staticmethod
    async def save_agent_insight(session_id: str, content: str):
        """
        Process agent output, extract insights, deduplicate, and store in Neo4j.
        
        Args:
            session_id: The unique ID of the agent session.
            content: The text content generated by the agent (conclusion/answer).
        """
        logger.info(f"Processing agent insight for session {session_id}...")
        
        # 1. Extract Entities
        entities = await MemoryManager.extract_knowledge(content)
        if not entities:
            logger.info("No insights extracted.")
            return

        driver = await Neo4jManager.get_driver()
        
        async with driver.session() as session:
            # Ensure AgentSession node exists
            # We assume session_id is unique.
            await session.run("""
                MERGE (s:AgentSession {session_id: $session_id})
                ON CREATE SET 
                    s.timestamp = datetime(), 
                    s.agent_name = 'SKE_Agent',
                    s.id = $session_id
            """, session_id=session_id)
            
            for entity in entities:
                # 2. Generate Embedding
                # Embed "Name: Description" for better semantic matching
                embedding_text = f"{entity.name}: {entity.description}"
                embedding = await MemoryManager.get_embedding(embedding_text)
                
                # 3. Vector Search for Duplicates
                # We search for existing entities with similar meaning
                search_query = """
                CALL db.index.vector.queryNodes('entity_embedding_index', 1, $embedding)
                YIELD node, score
                WHERE score > 0.92  // High threshold for deduplication to avoid merging distinct but related concepts
                RETURN node, score
                """
                
                result = await session.run(search_query, embedding=embedding)
                record = await result.single()
                
                target_id = None
                
                if record:
                    # Exists
                    existing_node = record["node"]
                    existing_name = existing_node.get('name')
                    score = record['score']
                    logger.info(f"Entity '{entity.name}' matches existing '{existing_name}' (score: {score:.4f}). Linking only.")
                    target_id = existing_node.element_id
                else:
                    # Not exists - Create new
                    logger.info(f"Creating new entity '{entity.name}' from agent insight.")
                    create_query = """
                    CREATE (e:Entity {
                        id: $id,
                        name: $name,
                        type: $type,
                        description: $description,
                        source: 'Agent',
                        embedding: $embedding
                    })
                    RETURN elementId(e) as id
                    """
                    create_result = await session.run(create_query, 
                        id=str(uuid.uuid4()),
                        name=entity.name,
                        type=entity.type,
                        description=entity.description,
                        embedding=embedding
                    )
                    create_record = await create_result.single()
                    target_id = create_record["id"]

                # 4. Create Relationship (AgentSession)-[:GENERATED]->(Entity)
                if target_id:
                    rel_query = """
                    MATCH (s:AgentSession {session_id: $session_id})
                    MATCH (e:Entity) WHERE elementId(e) = $target_id
                    MERGE (s)-[r:GENERATED]->(e)
                    SET r.timestamp = datetime(), r.reasoning = $reasoning
                    """
                    await session.run(rel_query, 
                        session_id=session_id, 
                        target_id=target_id,
                        reasoning=entity.reasoning
                    )

        logger.info(f"Saved {len(entities)} insights for session {session_id}.")

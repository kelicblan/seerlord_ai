<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SeerLord AI - Test Console</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }
        .main-container {
            display: flex;
            height: 100%;
            width: 100%;
        }
        
        /* Left Panel: Chat */
        .left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
            background: white;
            min-width: 400px;
        }
        .header {
            background-color: #007bff;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
        }
        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            border-bottom: 1px solid #ddd;
        }
        .message {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
        }
        .message.user {
            align-items: flex-end;
        }
        .message.ai {
            align-items: flex-start;
        }
        .bubble {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 15px;
            line-height: 1.5;
            position: relative;
            word-wrap: break-word;
        }
        .user .bubble {
            background-color: #007bff;
            color: white;
            border-bottom-right-radius: 0;
        }
        .ai .bubble {
            background-color: #e9ecef;
            color: #333;
            border-bottom-left-radius: 0;
        }
        .input-area {
            padding: 20px;
            display: flex;
            gap: 10px;
            background: #f9f9f9;
        }
        input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* Right Panel: Dashboard */
        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #f8f9fa;
            padding: 10px;
            overflow-y: auto;
            min-width: 400px;
        }
        .dashboard-header {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }
        .metric-card {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .metric-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        .metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #007bff;
        }
        
        /* Graph Container */
        .graph-card {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            margin-bottom: 10px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }
        #mermaidGraph {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }
        
        /* Graph Node States */
        .node-running rect, .node-running circle, .node-running polygon, .node-running path {
            fill: #fff9c4 !important;
            stroke: #fbc02d !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 5px #fbc02d);
        }
        .node-completed rect, .node-completed circle, .node-completed polygon, .node-completed path {
            fill: #e8f5e9 !important;
            stroke: #4caf50 !important;
            stroke-width: 2px !important;
        }

        .event-log {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 200px;
        }
        .log-header {
            padding: 10px 15px;
            background: #e9ecef;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
            font-size: 0.9em;
        }
        .log-content {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85em;
        }
        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 2px;
        }
        .log-time {
            color: #888;
            margin-right: 10px;
        }
        .log-type {
            font-weight: bold;
            margin-right: 10px;
            min-width: 60px;
            display: inline-block;
        }
        .log-detail {
            color: #333;
        }
        
        .typing {
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0% { opacity: .2; }
            20% { opacity: 1; }
            100% { opacity: .2; }
        }
    </style>
</head>
<body>

<div class="main-container">
    <!-- Left Panel -->
    <div class="left-panel">
        <div class="header">SeerLord AI Chat</div>
        <div class="messages" id="messages">
            <div class="message ai">
                <div class="bubble">您好！我是 SeerLord AI。请输入您的需求。</div>
            </div>
        </div>
        <div class="input-area">
            <select id="agentSelector" style="max-width: 150px;">
                <option value="">自动路由 (Auto)</option>
            </select>
            <input type="text" id="userInput" placeholder="输入您的指令..." onkeypress="handleKeyPress(event)">
            <button onclick="sendMessage()" id="sendBtn">发送</button>
        </div>
    </div>

    <!-- Right Panel -->
    <div class="right-panel">
        <div class="dashboard-header">Agent Execution Dashboard</div>
        
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-label">Status</div>
                <div class="metric-value" id="statusMetric">Idle</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Duration</div>
                <div class="metric-value" id="durationMetric">0.00s</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Total Tokens</div>
                <div class="metric-value" id="totalTokens">0</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Token Breakdown</div>
                <div class="metric-value" style="font-size: 0.9em;">In: <span id="inputTokens">0</span> | Out: <span id="outputTokens">0</span></div>
            </div>
            <!-- MCP Metrics -->
            <div class="metric-card" style="grid-column: span 4;">
                <div class="metric-label">MCP Services</div>
                <div class="metric-value" style="font-size: 0.9em;" id="mcpStatus">Loading...</div>
            </div>
        </div>
        
        <!-- Graph Visualization -->
        <div class="graph-card">
            <div class="log-header">Workflow Graph</div>
            <div id="mermaidGraph">Select an agent to view graph</div>
        </div>

        <div class="event-log">
            <div class="log-header">Execution Log</div>
            <div class="log-content" id="logContent">
                <div class="log-entry">Waiting for execution...</div>
            </div>
        </div>
    </div>
</div>

<script>
    const messagesDiv = document.getElementById('messages');
    const userInput = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    const agentSelector = document.getElementById('agentSelector');
    
    // Dashboard elements
    const statusMetric = document.getElementById('statusMetric');
    const durationMetric = document.getElementById('durationMetric');
    const totalTokensEl = document.getElementById('totalTokens');
    const inputTokensEl = document.getElementById('inputTokens');
    const outputTokensEl = document.getElementById('outputTokens');
    const logContent = document.getElementById('logContent');
    const mcpStatusEl = document.getElementById('mcpStatus');
    const graphDiv = document.getElementById('mermaidGraph');

    let threadId = "web-test-" + Date.now();
    let availablePlugins = []; // Store plugin IDs
    
    // Mermaid Init
    mermaid.initialize({ startOnLoad: false, theme: 'default' });

    // 初始化：加载插件列表和MCP状态
    async function loadPlugins() {
        try {
            const response = await fetch('/api/v1/plugins');
            const plugins = await response.json();
            availablePlugins = plugins.map(p => p.id);
            plugins.forEach(plugin => {
                const option = document.createElement('option');
                option.value = plugin.id;
                option.textContent = `${plugin.name}`;
                agentSelector.appendChild(option);
            });
        } catch (error) {
            console.error("Failed to load plugins:", error);
            addMessage('ai', 'System Error: Failed to load plugin list.');
        }
    }
    
    // Load Graph
    async function loadAgentGraph(agentId) {
        if (!agentId) {
            graphDiv.innerHTML = "Select an agent to view graph";
            return;
        }
        
        graphDiv.innerHTML = "Loading graph...";
        try {
            const response = await fetch(`/api/v1/agent/${agentId}/graph`);
            const data = await response.json();
            
            if (data.mermaid) {
                // Clear previous
                graphDiv.innerHTML = "";
                // Render new
                const { svg } = await mermaid.render('mermaidSvg' + Date.now(), data.mermaid);
                graphDiv.innerHTML = svg;
            } else {
                graphDiv.innerHTML = "No graph data available.";
            }
        } catch (e) {
            console.error("Graph load error:", e);
            graphDiv.innerHTML = "Failed to load graph.";
        }
    }
    
    // Highlight Node
    function highlightNode(nodeName, status) {
        // Find nodes by text content
        const nodes = graphDiv.querySelectorAll('.node');
        nodes.forEach(node => {
            // Check text content of the node label
            // The text is usually inside a <foreignObject> or <text> or <span> inside the node
            if (node.textContent.trim() === nodeName) {
                // Remove old classes
                node.classList.remove('node-running', 'node-completed');
                node.classList.add(`node-${status}`);
            }
        });
    }

    // Reset Graph Status
    function resetGraphNodes() {
        const nodes = graphDiv.querySelectorAll('.node');
        nodes.forEach(node => {
            node.classList.remove('node-running', 'node-completed');
        });
    }

    agentSelector.addEventListener('change', (e) => {
        loadAgentGraph(e.target.value);
    });
    
    async function loadMCPStatus() {
        try {
            const response = await fetch('/api/v1/mcp/status');
            const status = await response.json();
            
            let html = `Total Servers: ${status.total_servers} | Total Tools: ${status.total_tools}<br>`;
            html += `<div style="display:flex; gap:10px; margin-top:5px; flex-wrap:wrap;">`;
            status.servers.forEach(server => {
                html += `<span style="background:#e9ecef; padding:2px 8px; border-radius:4px; font-size:0.8em;">
                    ${server.name} (${server.tool_count} tools) <span style="color:green">●</span>
                </span>`;
            });
            html += `</div>`;
            mcpStatusEl.innerHTML = html;
        } catch (error) {
            console.error("Failed to load MCP status:", error);
            mcpStatusEl.innerText = "Error loading MCP status";
        }
    }

    loadPlugins();
    loadMCPStatus();

    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            sendMessage();
        }
    }

    function addMessage(role, text) {
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${role}`;
        
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.innerHTML = text.replace(/\n/g, '<br>');
        
        msgDiv.appendChild(bubble);
        messagesDiv.appendChild(msgDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        return bubble;
    }

    // Dashboard Helpers
    function logEvent(type, detail) {
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        const time = new Date().toLocaleTimeString();
        entry.innerHTML = `<span class="log-time">[${time}]</span><span class="log-type">${type}</span><span class="log-detail">${detail}</span>`;
        logContent.appendChild(entry);
        logContent.scrollTop = logContent.scrollHeight;
    }

    function resetDashboard() {
        statusMetric.innerText = "Running...";
        durationMetric.innerText = "0.00s";
        totalTokensEl.innerText = "0";
        inputTokensEl.innerText = "0";
        outputTokensEl.innerText = "0";
        logContent.innerHTML = "";
        resetGraphNodes();
    }

    async function sendMessage() {
        const text = userInput.value.trim();
        if (!text) return;

        addMessage('user', text);
        userInput.value = '';
        userInput.disabled = true;
        sendBtn.disabled = true;

        const aiBubble = addMessage('ai', '');
        aiBubble.innerHTML = '<span class="typing">Thinking...</span>';
        
        resetDashboard();
        logEvent("START", "Sending request to backend...");

        const startTime = Date.now();
        let timerInterval = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            durationMetric.innerText = elapsed.toFixed(2) + "s";
        }, 100);

        let totalTokens = 0;
        let inputTokens = 0;
        let outputTokens = 0;

        try {
            const selectedAgent = agentSelector.value;
            const payload = {
                input: {
                    messages: [
                        {
                            type: "human",
                            content: text
                        }
                    ]
                },
                config: {
                    configurable: {
                        thread_id: threadId
                    }
                }
            };
            
            if (selectedAgent) {
                payload.input.target_plugin = selectedAgent;
                logEvent("ROUTER", `Manual override: ${selectedAgent}`);
            }

            // Switch to stream_events for granular event visibility (including MCP tool calls)
            const response = await fetch('/api/v1/agent/stream_events', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    input: payload.input,
                    config: payload.config,
                    version: "v2" // Request v2 events
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            let buffer = '';
            let currentAiMessage = ''; // To accumulate streaming text

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop(); 

                for (const line of lines) {
                    if (line.trim() === '') continue;
                    
                    if (line.startsWith('event:')) {
                        // const eventType = line.slice(6).trim();
                        continue;
                    }
                    
                    if (line.startsWith('data: ')) {
                        try {
                            const jsonStr = line.slice(6);
                            const eventData = JSON.parse(jsonStr);
                            
                            // Debug: Log raw data
                            // console.log("Event:", eventData);

                            const eventType = eventData.event;
                            const eventName = eventData.name;
                            const eventTags = eventData.tags || [];

                            // --- MCP / Tool Events ---
                            if (eventType === 'on_tool_start') {
                                logEvent("MCP", `Started: ${eventName}`);
                            }
                            else if (eventType === 'on_tool_end') {
                                const status = eventData.data.output ? "SUCCESS" : "FAILED"; // simplistic check
                                logEvent("MCP", `Finished: ${eventName} (${status})`);
                            }
                            
                            // --- Node / Chain Events ---
                            // Filter out "LangGraph" internal chains to reduce noise, keep interesting nodes
                            else if (eventType === 'on_chain_start' && eventName && eventName !== 'LangGraph' && !eventName.startsWith('__')) {
                                logEvent("NODE", `Entering: ${eventName}`);
                                
                                // Auto-switch graph if we detect a plugin starting
                                if (availablePlugins.includes(eventName)) {
                                    // Only switch if selector is empty (Auto) or different
                                    if (agentSelector.value !== eventName) {
                                        agentSelector.value = eventName; // Update UI selector
                                        loadAgentGraph(eventName);
                                        logEvent("UI", `Switched view to: ${eventName}`);
                                    }
                                }
                                
                                highlightNode(eventName, 'running');
                            }
                            else if (eventType === 'on_chain_end' && eventName && eventName !== 'LangGraph' && !eventName.startsWith('__')) {
                                logEvent("NODE", `Finished: ${eventName}`);
                                highlightNode(eventName, 'completed');
                            }

                            // --- LLM Model Events ---
                            else if (eventType === 'on_chat_model_start') {
                                logEvent("MODEL", `Invoking: ${eventName || 'LLM'}`);
                            }
                            
                            // --- Streaming Content (Chat Model) ---
                            else if (eventType === 'on_chat_model_stream') {
                                const chunk = eventData.data.chunk;
                                if (chunk && chunk.content) {
                                    currentAiMessage += chunk.content;
                                    
                                    // Update Bubble
                                    const formatted = currentAiMessage
                                        .replace(/\n/g, '<br>')
                                        .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
                                    aiBubble.innerHTML = formatted;
                                }
                            }
                            
                            // --- Usage Metadata (at end of model call) ---
                            else if (eventType === 'on_chat_model_end') {
                                logEvent("MODEL", `Finished: ${eventName || 'LLM'}`);
                                if (eventData.data.output && eventData.data.output.usage_metadata) {
                                    const usage = eventData.data.output.usage_metadata;
                                    inputTokens += usage.input_tokens || 0;
                                    outputTokens += usage.output_tokens || 0;
                                    totalTokens += usage.total_tokens || 0;
                                    
                                    inputTokensEl.innerText = inputTokens;
                                    outputTokensEl.innerText = outputTokens;
                                    totalTokensEl.innerText = totalTokens;
                                }
                            }

                        } catch (e) {
                            console.error("Error parsing stream data:", e);
                        }
                    }
                }
            }
            
            statusMetric.innerText = "Completed";
            logEvent("END", "Stream finished.");

        } catch (error) {
            console.error("Stream error:", error);
            aiBubble.innerHTML += `<br><span style="color:red">Error: ${error.message}</span>`;
            statusMetric.innerText = "Error";
            logEvent("ERROR", error.message);
        } finally {
            clearInterval(timerInterval);
            userInput.disabled = false;
            sendBtn.disabled = false;
            userInput.focus();
            if (aiBubble.innerHTML === '<span class="typing">Thinking...</span>') {
                aiBubble.innerHTML = "No response received.";
            }
        }
    }
</script>

</body>
</html>
